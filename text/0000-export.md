- Feature Name: export
- Start Date: 2016-09-06
- RFC PR: (leave this empty)
- Pony Issue: (leave this empty)

# Summary

This RFC proposes the addition of an `export` keyword to specify that functions for a class should be generated even if they are not used directly in the Pony program that is being compiled. Additionally, wrapper functions for these functions that conform to the C ABI will be generated, along with a .h file with the appropriate function signatures so that the functions can be easily used from a C program. All of this will only be done if the program is compiled with the `--export` compiler flag.

# Motivation

Pony provides mechanisms for calling C functions and passing C structs in and out of those functions, but there is no easy way to work with Pony objects inside C function. It would be useful to pass Pony objects to C functions and call methods on those objects. This would allow programmers to work with complex Pony data structures inside C functions in a way that would not require translating those data structures into C structs.

# Detailed design

There are three major obstacles to working with Pony objects in C:
1. The compiler will not generate functions unless it has determined that they are reachable from the Pony program that is being compiled.
2. The compiler uses the the LLVM fast calling convention when it generates functions.
3. The programmer must create function declarations for the methods that will be used in the C program.

The `export` keyword would be used in a program to tell the compiler to mark the given class and all of its non-generic methods as reachable, generate wrapper functions for these functions that can be called using the C ABI, and produce a .h file with declarations for all of the `export`ed functions. These steps would only be taken if the program was compiled with the `--export` flag.

This program illustrates how the `export` keyword would be used in a Pony program:

```pony
// example.pony

use @my_fun[None](f: Foo)

export Foo

class Foo
  let _x: I64
  new create(x: I64) =>
    _x = x
  fun bar(): I64 => 2 * _x
  fun baz(): I64 => _x / 2

actor Main
  new create(env: Env) =>
    let foo = Foo(32)
    @my_fun(foo)
```

When compiled with the `--export` flag, a .h file would be produced:

```
// example.h

extern void *Foo_Alloc();
extern void *Foo_create(long);
extern long Foo_bar();
extern long Foo_baz();
```

The C library that contains the implementation of `my_fun` would then use the generated .h file (in this example, `example.h`):

```
// example.c

#include <stdio.h>
#include "example.h"

extern void my_fun(void *foo) {
  printf("Here's a number: %d\n", Foo_bar(foo) * Foo_baz(foo));
}
```

In the case of generic classes, type parameters would need to be specified in order to use `export`. For example, `export Map[String, String]` would need to be used rather than `export Map`. Otherwise the compiler would have to generate functions for every possible version of `Map`.

Since reference capabilities are enforced a compile-time but not a run-time there would be no need to produce wrappers for multiple versions of `box` functions, nor would there be a need to include reference capability information as part of the function name as is done for the internal functions that the compiler generates.

# How We Teach This

This feature would be documented in the Tutorial as part of the "C FFI" chapter, in a section called "Exporting Functions". The discussion would introduce these terms:
* *Exported Class* : A class whose functions are generated by the compiler even if none of them are called in the Pony program that is being compiled.
* *Wrapper Function* : A function that is callable from C that in turn calls the underlying Pony function for an exported class.
* *Exported Header* : A .h file that declares the generated wrapper functions that can be used by a C library.
This would serve as the primary documentation for both existing Pony users and new Pony users.

The compiler `--export` argument would be documented in the "Compiler Arguments" appendix.

There is currently no discussion in the tutorial about reachability analysis; it might be useful to add a section about this, possibly as an appendix, in order to better explain what this feature does.

# Drawbacks

The C FFI is already somewhat dangerous because it lacks the type safety and reference capability guarantees that Pony provides; it might be reasonable to discourage developers from using it for anything other than constrained tasks that operate only on basic data types.

# Alternatives

Instead of specifying exported classes in a Pony source file, the list of classes could be specified in some other type of file, or even passed to the compiler as part of the `--export` argument. The concern here is that this would separate information about what is exported from the program where it is used.

Instead of specifying a class to export, the `export` keyword could take a combination of the class name and function name. This option would provide more granular control over what gets exported, but it would also require more significant syntax changes to the compiler. It seems safe to assume that if the programmer wanted to use a class in a C program then they would potentially use all of the functions provided by that class. Unused exported functions could be stripped if the Pony program and the library are statically linked, which would avoid any issues of bloat in the executable.

If this is not done then there is no way to call class functions on objects from C.

# Unresolved questions

It would be nice to have a way of exporting concrete implementation of generic functions. One way of doing that would be to expand the `export syntax` to allow function names to be given with their type parameters specified. For example, to export `Foo.bar` where `bar` is parameterized with `I64` the developer would do this:

```pony
export Foo.bar[I64]

class Foo
  fun bar[T: Real[T] val](x: T): T => x
```

It might also be useful to expand the `export` keyword to include an optional `as` argument that could be used to control the name given to the wrapper function in order to control potentially unwieldy wrapper function names.
